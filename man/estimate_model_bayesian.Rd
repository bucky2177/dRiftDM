% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/core_bayes_estimate.R
\name{estimate_model_bayesian}
\alias{estimate_model_bayesian}
\title{(Hierarchical) Bayesian Estimation}
\usage{
estimate_model_bayesian(
  drift_dm_obj,
  mean = NULL,
  algorithm = "de_mcmc",
  obs_data_ids = NULL,
  n_chains = 40,
  burn_in = 500,
  samples = 2000,
  prob_migration = 0.1,
  prob_re_eval = 0.1,
  progress = 2,
  seed = NULL,
  ...
)
}
\arguments{
\item{drift_dm_obj}{an object of type \link{drift_dm}.}

\item{mean}{numeric vector or a list, specifying the expected mean of each
parameter to be optimized (see the Details below).}

\item{algorithm}{character string, indicating the sampling algorithm to use.
Must be either \code{"de_mcmc"} (default) or \code{"tide"}.}

\item{obs_data_ids}{data.frame for the hierarchical case. An additional
column ID is necessary that codes the individuals (see also
\link{obs_data}).}

\item{n_chains}{numeric, number of chains for the MCMC-sampler.
Default is \code{40}.}

\item{burn_in}{numeric, number of burn-in iterations. Default is \code{500}.}

\item{samples}{numeric, number of sampling iterations after burn-in.
Default is \code{2000}.}

\item{prob_migration}{numeric, probability of performing a migration
crossover step during burn-in. Default is \code{0.1} (i.e., 10\%).}

\item{prob_re_eval}{numeric, probability of re-evaluating the
likelihood/posterior values of the previous iteration \code{i-1} when deciding
for the acceptance of the proposal in iteration \code{i}. Only considered during
burn-in. Default is \code{0.1} (i.e., 10\%).}

\item{progress}{integer, indicating progress output: 0 (none),
1 (minimal text output), or 2 (text output and progress bar). Default is \code{2}.}

\item{seed}{optional random seed for reproducibility.}

\item{...}{Additional parameters passed forward to
\code{\link[=estimate_bayes_h]{estimate_bayes_h()}} and \code{\link[=estimate_bayes_one_subj]{estimate_bayes_one_subj()}}, and
from there potentially to \code{\link[=get_default_prior_settings]{get_default_prior_settings()}} to alter
the prior settings.}
}
\value{
An object of type \code{drift_dm_mc} containing posterior samples for
parameters, log-posterior values, and log-likelihoods. In the hierarchical
case, the respective values are available at both the group-level and the
individual-level. The object contains two attributes: \code{algorithm} and
\code{data_model}. The former simply stores the type of algorithm that was used
and codes whether estimation was done in a hierarchical fashion or not.
The latter either contains the model and the attached data (in the
non-hierarchical case) or a named list of model copies with each
individual's data attached.
}
\description{
This function provides a wrapper around the implemented algorithms for
Bayesian inference in dRiftDM. For parameter estimation,
Differential Evolution Markov-Chain Monte-Carlo (DE-MCMC)
\insertCite{Turneretal.2013;textual}{dRiftDM} is used.
An approximation of the marginal likelihood to calculate Bayes Factors can
be obtained with the Thermodynamic Integration via Differential Evolution
(TIDE) algorithm \insertCite{EvansAnnis2019;textual}{dRiftDM}.
}
\details{
When users supply a \link{data.frame} via the optional argument \code{obs_data_ids},
a hierarchical approach to parameter estimation is done. In this case,
the supplied data set must provide data for multiple individuals. If users
want to estimate the parameters for single individual (i.e., pursue the
non-hierarchical approach), then the supplied model \code{drift_dm_obj} must
have data attached to it (see \code{\link[=obs_data]{obs_data()}}).

The hierarchical case is covered by the internal function
\code{\link[=estimate_bayes_h]{estimate_bayes_h()}}. The non-hierarchical case by the internal
function \code{\link[=estimate_bayes_one_subj]{estimate_bayes_one_subj()}}.
\subsection{(Default) Prior settings in the non-hierarchical case:}{

Let \eqn{\theta^{(j)}} indicate parameter \eqn{j} of a model (e.g., the
drift rate).
The prior on \eqn{\theta^{(j)}} is a truncated normal distribution:
\deqn{
 \theta^{(j)} \sim NT(\mu^{(j)}, \sigma^{(j)}, l^{(j)}, u^{(j)})
 }
With \eqn{\mu^{(j)}} and \eqn{\sigma^{(j)}} representing the mean and standard
deviation of parameter \eqn{j}. \eqn{l^{(j)}} and \eqn{u^{(j)}} represent the
lower and upper boundary. \eqn{\mu^{(j)}} is taken from the necessary \code{mean}
argument when calling the function. \eqn{\sigma^{(j)}} is, per default, equal
to \eqn{\mu^{(j)}}. This can be changed by passing an optional \code{sd} argument.
The lower and upper boundaries of the truncated normal are \code{-Inf} and \code{Inf}
per default. This can be altered by passing the optional arguments
\code{lower} and  \code{upper}.
}

\subsection{(Default) Prior settings in the hierarchical case:}{

Let \eqn{\theta_i^{(j)}} indicate parameter \eqn{j} for participant \eqn{i}
(e.g., the  drift rate estimated for individual \eqn{i}). The prior on
\eqn{\theta_i^{(j)}} is a truncated normal distribution:
\deqn{
 \theta_i^{(j)} \sim NT(\mu^{(j)}, \sigma^{(j)}, l^{(j)}, u^{(j)})
 }
With \eqn{\mu^{(j)}} and \eqn{\sigma^{(j)}} representing the mean and standard
deviation of parameter \eqn{j} at the group level. \eqn{l^{(j)}} and
\eqn{u^{(j)}} represent the lower and upper boundary. The lower and upper
boundaries of the truncated normal are \code{-Inf} and \code{Inf} per default.
This can be altered by passing the optional arguments \code{lower} and  \code{upper}.

For a group-level mean parameter, \eqn{\mu^{(j)}}, the prior is also a truncated
normal distributions:
\deqn{
 \mu^{(j)} \sim NT(M^{(j)}, SD^{(j)}, l^{(j)}, u^{(j)})
 }
With \eqn{M^{(j)}} specified by the necessary \code{mean} argument  when calling the
function. \eqn{SD^{(j)}} is, per default, equal to \eqn{M^{(j)}}. This can be
changed by passing an optional \code{sd} argument, specifying the \code{sd}s.

For a group-level standard deviation parameter, \eqn{\sigma^{(j)}}, the prior
is a gamma distribution:
\deqn{
 \sigma^{(j)} \sim \Gamma(shape^{(j)},rate^{(j)})
 }
With \eqn{shape^{(j)}} and \eqn{rate^{(j)}} being \code{1} by default. This
can be changed by passing the optional arguments \code{shape} and \code{rate}.
}

\subsection{Specifying prior settings}{

the function \code{estimate_model_bayesian} passes the (optional) prior arguments
like \code{mean}, \code{sd}, \code{lower}, \code{upper}, \code{shape}, and \code{rate} forward
to \code{\link[=get_default_prior_settings]{get_default_prior_settings()}} to specify prior settings. Similar
to specifying the search space in \code{\link[=estimate_model]{estimate_model()}}, there are
three options how to provide the optional prior arguments.
\itemize{
\item Plain numeric vectors (not very much recommended). In this case,
\code{mean}, \code{sd}, \code{lower}, \code{upper}, \code{shape}, and \code{rate} must be sorted in
accordance with the parameters in the \code{flex_prms_obj} object that vary for
at least one condition (call \code{print(drift_dm_obj)} and have a look at the
\verb{Unique Parameters} output)
\item Named numeric vectors. In this case \code{mean}, \code{sd}, \code{lower}, \code{upper},
\code{shape}, and \code{rate} have to provide labels in accordance with the parameters
that are considered "free" at least once across conditions.
\item The most flexible way is when \code{mean}, \code{sd}, \code{lower}, \code{upper}, \code{shape}, and
\code{rate} are lists. In this case, each list requires an entry called
"default_values" which specifies the named or plain numeric vectors as above.
If the lists only contain the entry "default_values", then the behavior is
as if \code{mean}, \code{sd}, \code{lower}, \code{upper}, \code{shape}, and \code{rate} were already
numeric vectors.
However, the lists can also provide entries labeled like specific
conditions, which contain named (!) numeric vectors with parameter labels.
This will modify the value for the prior settings with respect
to the specified parameters in the respective conditions.
}
}
}
\examples{

# This is an example that shows the function but is unrealistic to ensure it
# runs in a couple of seconds.

####
# Hierarchical case:
# get a model for demonstration purpose
my_model  = dmc_dm(dx = .01, dt = .005, t_max = 1.5, var_start = FALSE)

# get some data (3 participants of a flanker task data set)
some_data = ulrich_flanker_data[ulrich_flanker_data$ID \%in\% 1:3,]

results <- estimate_model_bayesian(
  drift_dm_obj = my_model,
  mean =  c(muc = 4, b = 0.6, non_dec = 0.3, sd_non_dec = 0.02,
            tau = 0.06, A = 0.1), # mean prior settings
  obs_data_ids = ulrich_flanker_data,
  n_chains = 20,     # just for the example
  burn_in = 0,       # just for the example
  samples = 1,       # just for the example
  n_cores = 1,       # just for the example
  lower = c(muc = 0, b = 0, non_dec = 0, sd_non_dec = 0.005,
            tau = 0.005) # altered prior settings for the lower truncation
 )

####
# Non-Hierarchical case (estimation for just one individual)
my_model  = dmc_dm(dx = .01, dt = .005, t_max = 1.5, var_start = FALSE)

# get some data (3 participants of the flanker task data set)
obs_data(my_model) = ulrich_flanker_data[ulrich_flanker_data$ID == 1,]

results <- estimate_model_bayesian(
  drift_dm_obj = my_model,
  mean =  c(muc = 4, b = 0.6, non_dec = 0.3, sd_non_dec = 0.02,
            tau = 0.06, A = 0.1),  # mean prior settings
  n_chains = 20,     # just for the example
  burn_in = 0,       # just for the example
  samples = 1,       # just for the example
  lower = c(muc = 0, b = 0, non_dec = 0, sd_non_dec = 0.005,
            tau = 0.005) # altered prior settings for the lower truncation
 )



}
\references{
\insertRef{Turneretal.2013}{dRiftDM}
\insertRef{EvansAnnis2019}{dRiftDM}
}
