% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/core_estimate.R, R/formatting_fits_agg_dm.R,
%   R/formatting_mcmc_dm.R
\name{estimate_dm}
\alias{estimate_dm}
\alias{print.fits_agg_dm}
\alias{print.mcmc_dm}
\title{Fit a DDM to observed data}
\usage{
estimate_dm(
  drift_dm_obj,
  obs_data = NULL,
  approach = NULL,
  framework = NULL,
  optimizer = NULL,
  control = list(),
  n_cores = 1,
  parallelization_strategy = NULL,
  lower = NULL,
  upper = NULL,
  start_vals = NULL,
  means = NULL,
  sds = NULL,
  shapes = NULL,
  rates = NULL,
  n_chains = 40,
  burn_in = 500,
  samples = 1000,
  prob_migration = 0.1,
  prob_re_eval = 1,
  messaging = TRUE,
  seed = NULL,
  ...
)

\method{print}{fits_agg_dm}(x, ...)

\method{print}{mcmc_dm}(x, ..., round_digits = drift_dm_default_rounding())
}
\arguments{
\item{drift_dm_obj}{a \link{drift_dm} object containing the model to be
fitted.}

\item{obs_data}{an optional \link{data.frame} (see also \link{obs_data}).
If no \code{ID} column is present, a single-individual setup is assumed.
If an \code{ID} column is present, the model is fitted separately for each individual.}

\item{approach}{an optional character string, can be \code{"separately"},
\code{"aggregated"} or \code{"hierarchical"}.}

\item{framework}{a character string, one of \code{"classical"} or \code{"bayesian"}.
This argument is adjusted automatically for incompatible combinations of
\code{approach} and \code{framework} (e.g., \code{"hierarchical"} implies \code{"bayesian"}).
Defaults to \code{"classical"}.}

\item{optimizer}{a character string. For the classical framework, one of
\code{"nmkb"}, \code{"nmk"}, \code{"BFGS"}, \code{"L-BFGS-B"}, \code{"DEoptim"}. For the Bayesian
framework, only \code{"DE-MCMC"} is currently supported. If \code{NULL} and the
framework is \code{"classical"}, \code{"DEoptim"} or \code{"nmk"} is used, depending
on whether \code{lower/upper} are provided or not. If \code{NULL} and
the framework is \code{"bayesian"}, then \verb{"DE-MCMC} is used. Note that
\code{"BFGS"} and \code{"L-BFGS-B"} are often unstable.}

\item{control}{a list of control parameters passed to the optimizer
(see \link[dfoptim:nmkb]{dfoptim::nmk}, \link[dfoptim:nmkb]{dfoptim::nmkb}, \link[DEoptim:DEoptim]{DEoptim::DEoptim}, \link[stats:optim]{stats::optim})}

\item{n_cores}{an integer > 0, indicating the number of CPU cores/threads to
use (at the moment, this doesn't have an effect when fitting a single
individual within the Bayesian framework).}

\item{parallelization_strategy}{an integer, controlling how parallelization
is performed when fitting multiple individuals with the classical approach.
If \code{1}, parallelization is across individuals. If \code{2}, parallelization is
within individuals (currently only supported for \code{"DEoptim"}). Defaults to
\code{2} if \code{optimizer = "DEoptim"}, otherwise to \code{1}.}

\item{lower, upper}{numeric vectors or lists, specifying the lower and upper
bounds on each parameter to be optimized (see Details).}

\item{start_vals}{optional starting values for classical single-subject fits
and when using an optimizer that requires a starting value. Can be
a numeric vector of model parameters when fitting a single individual, or
a \code{data.frame} with columns for each model parameter. In the latter case,
enables multi-start (one row per start). For \code{'approach = "separately"'}, a
\code{data.frame} with an \code{ID} column is required.}

\item{means, sds, shapes, rates}{optional numeric vectors for prior
specification (when using the Bayesian framework, see Details).}

\item{n_chains}{an integer, providing the number of MCMC chains (Bayesian
framework).}

\item{burn_in}{an integer, number of burn-in iterations (Bayesian
framework).}

\item{samples}{an integer, number of post-burn-in samples per chain (
Bayesian framework).}

\item{prob_migration}{a numeric in \verb{[0,1]}, controlling the migration
probability of the \code{DE-MCMC} algorithm (Bayesian framework).}

\item{prob_re_eval}{a numeric in \verb{[0,1]}, probability to re-evaluate the
model at current group-level parameters during sampling (Bayesian
framework; only relevant for the hierarchical case).}

\item{messaging}{a logical, if \code{TRUE} progress/info messages are printed}

\item{seed}{an optional integer to set the RNG seed for reproducibility.}

\item{...}{additional arguments forwarded to lower-level routines. Options
are: \code{progress/verbose} (integers, for controlling progress bars and
verbosity of estimation infos), \code{rounding} (for controlling rounding when
printing individual model evaluations; if \code{verbose = 2}), \code{return_runs}
(when fitting a single individual and starting the estimation
routine with multiple starting points; if \code{TRUE}, then a list of all
routines is returned), \code{probs/n_bins} (the quantile levels and the number
of CAF bins when fitting aggregated data using the RMSE cost function).}
}
\value{
\itemize{
\item If fitting a single individual: either a \code{drift_dm} object with
fitted parameters (for the classical optimization framework) or
an object of type \code{mcmc_dm} (for the Bayesian framework)
\item If fitting multiple individuals separately: a \code{fits_ids_dm} object
containing all the individual model fits and some estimation info.
\item If fitting aggregated data: a \code{fits_agg_dm} object containing the model
itself and the raw data.
\item If fitting multiple individuals hierarchically: an object of type
\code{mcmc_dm}.
}
}
\description{
\code{estimate_dm()} is the main function to fit a drift diffusion model (DDM)
in \code{dRiftDM}. Several ways of fitting a model are supported: fitting a single
participant, fitting multiple participants separately or aggregated, and
fitting a (hierarchical) Bayesian model. The particular way is controlled
via the \code{approach} and \code{framework} arguments.

Note that not all combinations of \code{approach} and \code{framework} are currently
supported. Also, the hierarchical estimation procedure is in an experimental
stage.
}
\details{
For aggregated fits, aggregated statistics are set to the model and the cost
function is switched to \code{"rmse"}. If incompatible settings are requested,
the function switches to a compatible configuration and informs the user
with messages (these messages can be suppressed via the \code{messaging} argument).
Lower and upper parameter bounds are required for \code{"nmkb"}, \code{"L-BFGS-B"},
and \code{"DEoptim"} optimizer.
\subsection{Specifying \code{lower/upper} for Classical optimization}{

the function \code{estimate_model_dm()} provides a flexible way of specifying the
optimization space; this is identical to specifying the parameter simulation
space in \code{\link[=simulate_data.drift_dm]{simulate_data.drift_dm()}}.

Users have three options to specify the search space (see also the examples
below):
\itemize{
\item Plain numeric vectors (not very much recommended). In this case,
\code{lower/upper} must be sorted in accordance with the parameters in the
underlying \link{flex_prms} object of \code{drift_dm_obj} that vary for at
least one condition (call \code{print(drift_dm_obj)} and have a look at the
columns of the \verb{Unique Parameters} output; for each column that has a
number > 0, specify an entry in \code{lower/upper}).
\item Named numeric vectors. In this case \code{lower/upper} have to provide labels
in accordance with the parameters that are considered "free" at least once
across conditions (call \code{coef(drift_dm_obj)} and provide one named entry for
each parameter; dRiftDM will try to recycle parameter values across
conditions).
\item The most precise way is when \code{lower/upper} are lists. In this case, the
list requires an entry called "default_values" which specifies the named or
plain numeric vectors as above. If the list only contains this entry, then
the behavior is as if \code{lower/upper} were already numeric vectors. However,
the \code{lower/upper} lists can also provide entries labeled as specific
conditions, which contain named (!) numeric vectors with parameter labels.
This will modify the value for the upper/lower parameter space with respect
to the specified parameters in the respective condition.
}
}

\subsection{Specifying Priors for Bayesian Estimation}{

\strong{(Default) Prior settings in the non-hierarchical case:}

Let \eqn{\theta^{(j)}} indicate parameter \eqn{j} of a model (e.g., the
drift rate).
The prior on \eqn{\theta^{(j)}} is a truncated normal distribution:
\deqn{
 \theta^{(j)} \sim NT(\mu^{(j)}, \sigma^{(j)}, l^{(j)}, u^{(j)})
 }
With \eqn{\mu^{(j)}} and \eqn{\sigma^{(j)}} representing the mean and standard
deviation of parameter \eqn{j}. \eqn{l^{(j)}} and \eqn{u^{(j)}} represent the
lower and upper boundary. \eqn{\mu^{(j)}} is taken from the \code{mean}
argument or the currently set model parameters (i.e., from
\code{coef(drift_dm_obj)}) when calling the function. \eqn{\sigma^{(j)}} is, per
default, equal to \eqn{\mu^{(j)}}. This can be changed by passing
the \code{sd} argument. The lower and upper boundaries of the truncated normal
are \code{-Inf} and \code{Inf} per default. This can be altered by passing the
arguments \code{lower} and  \code{upper}.

\strong{(Default) Prior settings in the hierarchical case:}

Let \eqn{\theta_i^{(j)}} indicate parameter \eqn{j} for participant \eqn{i}
(e.g., the  drift rate estimated for individual \eqn{i}). The prior on
\eqn{\theta_i^{(j)}} is a truncated normal distribution:
\deqn{
 \theta_i^{(j)} \sim NT(\mu^{(j)}, \sigma^{(j)}, l^{(j)}, u^{(j)})
 }
With \eqn{\mu^{(j)}} and \eqn{\sigma^{(j)}} representing the mean and
standard deviation of parameter \eqn{j} at the group level. \eqn{l^{(j)}} and
\eqn{u^{(j)}} represent the lower and upper boundary. The lower and upper
boundaries of the truncated normal are \code{-Inf} and \code{Inf} per default.
This can be altered by passing the arguments \code{lower} and  \code{upper}.

For a group-level mean parameter, \eqn{\mu^{(j)}}, the prior is also a
truncated normal distributions:
\deqn{
 \mu^{(j)} \sim NT(M^{(j)}, SD^{(j)}, l^{(j)}, u^{(j)})
 }
With \eqn{M^{(j)}} specified by the \code{mean} argument or the currently
set model parameters. \eqn{SD^{(j)}} is, per default, equal to \eqn{M^{(j)}}.
This can be changed by passing the \code{sd} argument.

For a group-level standard deviation parameter, \eqn{\sigma^{(j)}}, the prior
is a gamma distribution:
\deqn{
 \sigma^{(j)} \sim \Gamma(shape^{(j)},rate^{(j)})
 }
With \eqn{shape^{(j)}} and \eqn{rate^{(j)}} being \code{1} by default. This
can be changed by passing the arguments \code{shape} and \code{rate}.

\strong{Specifying Prior Settings/Arguments}

Argument specification for \code{mean}, \code{sd}, \code{lower}, \code{upper}, \code{shape} and
\code{rate} is conceptually identical to specifying \code{lower/upper} for the
classical optimization approach (see the subsection above and the examples
below).
}
}
\note{
\code{estimate_dm} dispatches to underlying estimation routines that are not
exported:
\itemize{
\item Classical optimization of one individual via
\code{\link[=estimate_classical]{estimate_classical()}}
\item Classical optimization of multiple individuals via
\code{\link[=estimate_classical_wrapper]{estimate_classical_wrapper()}}
\item Bayesian estimation via \code{\link[=estimate_bayesian]{estimate_bayesian()}}.
\item Aggregated fitting is handled within \code{estimate_dm()} in combination with
\code{\link[=estimate_classical]{estimate_classical()}}
}
}
\examples{
##########
# Note: The following examples were trimmed for speed to ensure they run
# within seconds. They do not provide realistic settings.
##########
tic()
# get a model for the examples (DMC with just two free parameters)
model <- dmc_dm(
  t_max = 1.5, dx = .01, dt = .01, # very coarse settings for speed
  instr = '
   b <!>
   non_dec <!>
   sd_non_dec <!>
   tau <!>
   alpha <!>
   '
)
# simulate two data sets under the model (for demonstration purpose)
lower <- c(muc = 1, A = 0.05)
upper <- c(muc = 7, A = 0.15)
synth_data_prms <- simulate_data(
  model, n = 200, k = 2, lower = lower, upper = upper, seed = 1
)
synth_data <- synth_data_prms$synth_data


####
# Fit a single individual (using unbounded Nelder-Mead)
one_subj <- synth_data[synth_data$ID == 1,] # data of one individual
obs_data(model) <- one_subj
fit <- estimate_dm(
  drift_dm_obj = model,
  optimizer = "nmk"
)
print(fit)


####
# Fit a single individual (using bounded Nelder-Mead and custom starting
# values)
fit <- estimate_dm(
  drift_dm_obj = model,
  optimizer = "nmkb",
  lower = lower, upper = upper,
  start_vals = c(muc = 4, A = 0.06)
)
print(fit)

####
# Fit multiple individuals (separately; using bounded Nelder-Mead)
fit <- estimate_dm(
  drift_dm_obj = model,
  obs_data = synth_data, # contains data for two individuals
  optimizer = "nmkb",
  lower = lower, upper = upper
)
print(fit)
coef(fit)


###
# Fit to aggregated data (using unbounded Nelder-Mead)
fit <- estimate_dm(
  drift_dm_obj = model,
  obs_data = synth_data, # contains data for two individuals
  optimizer = "nmk",
  approach = "agg"
)
print(fit)
coef(fit)


###
# Fit a single individual (using DE-MCMC; Bayesian)
fit <- estimate_dm(
  drift_dm_obj = model,
  optimizer = "DE-MCMC",
  burn_in = 2, # this is usually way higher
  samples = 2, # this too
  n_chains = 10 # this too
)
print(fit)
coef(fit)


###
# Fit multiple individuals (using DE-MCMC; hierarchical Bayesian)
fit <- estimate_dm(
  drift_dm_obj = model,
  obs_data = synth_data, # contains data for two individuals
  optimizer = "DE-MCMC",
  burn_in = 2, # this is usually way higher
  samples = 2, # this too
  n_chains = 10 # this too
)
print(fit)
coef(fit)
toc()

}
\seealso{
\code{\link[=estimate_classical]{estimate_classical()}}, \code{\link[=estimate_bayesian]{estimate_bayesian()}},
\code{\link[=estimate_classical_wrapper]{estimate_classical_wrapper()}}, \code{\link[=get_parameters_smart]{get_parameters_smart()}}
}
