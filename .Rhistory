container = c(caf_temp(rts_corr[1], rts_err[1]),
caf_temp(rts_corr[-1], rts_err[-1]))
return(container)
}
all_cafs = caf_temp(all_rts_corr, all_rts_err)
calc_cafs_obs <- function(drift_dm_obj) {
if (is.null(drift_dm_obj$obs_data$rts_corr))
return(NULL)
if (is.null(drift_dm_obj$obs_data$rts_err))
return(NULL)
all_rts_corr = drift_dm_obj$obs_data$rts_corr
all_rts_err = drift_dm_obj$obs_data$rts_err
stopifnot(all(names(all_rts_corr) == names(all_rts_err)))
# rts_corr and rts_err are a list of rts. Calculates the caf using recursion
caf_temp <- function(list_rts_corr, list_rts_err) {
stopifnot(length(list_rts_corr) == length(list_rts_err))
if (length(rts_corr) == 1) {
rts_corr = list_rts_corr[[1]]
rts_err = list_rts_err[[1]]
rts = c(rts_corr, rts_err)
probs = default_caf_probs()
borders <- quantile(rts, probs = probs)
bins <- cut(rts, breaks = borders, labels = FALSE, include.lowest = TRUE)
stopifnot(length(unique(bins)) ==  length(probs)-1)
corr = rep(c(1,0), times = c(length(rts_corr), length(rts_err)))
temp = data.frame(corr = corr,
bins = bins)
caf = tapply(corr, bins, mean)
caf = data.frame(Bin = names(caf),
Caf = as.numeric(caf),
Cond = names(list_rts_corr))
return(list(caf))
}
container = c(caf_temp(list_rts_corr[1], list_rts_err[1]),
caf_temp(list_rts_cor[-1], list_rts_err[-1]))
return(container)
}
all_cafs = caf_temp(all_rts_corr, all_rts_err)
caf_final <- do.call(rbind, all_cafs)
return(caf_final)
}
# rts_corr and rts_err are a list of rts. Calculates the caf using recursion
caf_temp <- function(list_rts_corr, list_rts_err) {
stopifnot(length(list_rts_corr) == length(list_rts_err))
if (length(rts_corr) == 1) {
rts_corr = list_rts_corr[[1]]
rts_err = list_rts_err[[1]]
rts = c(rts_corr, rts_err)
probs = default_caf_probs()
borders <- quantile(rts, probs = probs)
bins <- cut(rts, breaks = borders, labels = FALSE, include.lowest = TRUE)
stopifnot(length(unique(bins)) ==  length(probs)-1)
corr = rep(c(1,0), times = c(length(rts_corr), length(rts_err)))
temp = data.frame(corr = corr,
bins = bins)
caf = tapply(corr, bins, mean)
caf = data.frame(Bin = names(caf),
Caf = as.numeric(caf),
Cond = names(list_rts_corr))
return(list(caf))
}
container = c(caf_temp(list_rts_corr[1], list_rts_err[1]),
caf_temp(list_rts_cor[-1], list_rts_err[-1]))
return(container)
}
all_cafs = caf_temp(all_rts_corr, all_rts_err)
all_cafs = caf_temp(all_rts_corr, all_rts_err)
# rts_corr and rts_err are a list of rts. Calculates the caf using recursion
caf_temp <- function(list_rts_corr, list_rts_err) {
stopifnot(length(list_rts_corr) == length(list_rts_err))
if (length(rts_corr) == 1) {
rts_corr = list_rts_corr[[1]]
rts_err = list_rts_err[[1]]
rts = c(rts_corr, rts_err)
probs = default_caf_probs()
borders <- quantile(rts, probs = probs)
bins <- cut(rts, breaks = borders, labels = FALSE, include.lowest = TRUE)
stopifnot(length(unique(bins)) ==  length(probs)-1)
corr = rep(c(1,0), times = c(length(rts_corr), length(rts_err)))
temp = data.frame(corr = corr,
bins = bins)
caf = tapply(corr, bins, mean)
caf = data.frame(Bin = names(caf),
Caf = as.numeric(caf),
Cond = names(list_rts_corr))
return(list(caf))
}
container = c(caf_temp(list_rts_corr[1], list_rts_err[1]),
caf_temp(list_rts_cor[-1], list_rts_err[-1]))
return(container)
}
all_cafs = caf_temp(all_rts_corr, all_rts_err)
rm(list = ls())
one_dm = ratcliff_dm()
load_all()
rm(list = ls())
one_dm = ratcliff_dm()
# simulate data
data = simulate_data(one_dm, 10000, seed = 1)
# set the data
one_dm = set_data(drift_dm_obj = one_dm, obs_data = data, eval_model = T)
one_dm = set_solver_setting(one_dm, "solver", "bla")
drift_dm_obj = one_dm
all_rts_corr = drift_dm_obj$obs_data$rts_corr
all_rts_err = drift_dm_obj$obs_data$rts_err
all_rts_corr
all_rts_corr$bla = runif(100)
all_rts_err$bla = runif(100)
all_rts_err$foo = runif(100)
all_rts_corr$foo = runif(100)
stopifnot(all(names(all_rts_corr) == names(all_rts_err)))
# rts_corr and rts_err are a list of rts. Calculates the caf using recursion
caf_temp <- function(list_rts_corr, list_rts_err) {
stopifnot(length(list_rts_corr) == length(list_rts_err))
if (length(rts_corr) == 1) {
rts_corr = list_rts_corr[[1]]
rts_err = list_rts_err[[1]]
rts = c(rts_corr, rts_err)
probs = default_caf_probs()
borders <- quantile(rts, probs = probs)
bins <- cut(rts, breaks = borders, labels = FALSE, include.lowest = TRUE)
stopifnot(length(unique(bins)) ==  length(probs)-1)
corr = rep(c(1,0), times = c(length(rts_corr), length(rts_err)))
temp = data.frame(corr = corr,
bins = bins)
caf = tapply(corr, bins, mean)
caf = data.frame(Bin = names(caf),
Caf = as.numeric(caf),
Cond = names(list_rts_corr))
return(list(caf))
}
container = c(caf_temp(list_rts_corr[1], list_rts_err[1]),
caf_temp(list_rts_cor[-1], list_rts_err[-1]))
return(container)
}
all_cafs = caf_temp(all_rts_corr, all_rts_err)
# rts_corr and rts_err are a list of rts. Calculates the caf using recursion
caf_temp <- function(list_rts_corr, list_rts_err) {
stopifnot(length(list_rts_corr) == length(list_rts_err))
if (length(list_rts_corr) == 1) {
rts_corr = list_rts_corr[[1]]
rts_err = list_rts_err[[1]]
rts = c(rts_corr, rts_err)
probs = default_caf_probs()
borders <- quantile(rts, probs = probs)
bins <- cut(rts, breaks = borders, labels = FALSE, include.lowest = TRUE)
stopifnot(length(unique(bins)) ==  length(probs)-1)
corr = rep(c(1,0), times = c(length(rts_corr), length(rts_err)))
temp = data.frame(corr = corr,
bins = bins)
caf = tapply(corr, bins, mean)
caf = data.frame(Bin = names(caf),
Caf = as.numeric(caf),
Cond = names(list_rts_corr))
return(list(caf))
}
container = c(caf_temp(list_rts_corr[1], list_rts_err[1]),
caf_temp(list_rts_cor[-1], list_rts_err[-1]))
return(container)
}
all_cafs = caf_temp(all_rts_corr, all_rts_err)
# rts_corr and rts_err are a list of rts. Calculates the caf using recursion
caf_temp <- function(list_rts_corr, list_rts_err) {
stopifnot(length(list_rts_corr) == length(list_rts_err))
if (length(list_rts_corr) == 1) {
rts_corr = list_rts_corr[[1]]
rts_err = list_rts_err[[1]]
rts = c(rts_corr, rts_err)
probs = default_caf_probs()
borders <- quantile(rts, probs = probs)
bins <- cut(rts, breaks = borders, labels = FALSE, include.lowest = TRUE)
stopifnot(length(unique(bins)) ==  length(probs)-1)
corr = rep(c(1,0), times = c(length(rts_corr), length(rts_err)))
temp = data.frame(corr = corr,
bins = bins)
caf = tapply(corr, bins, mean)
caf = data.frame(Bin = names(caf),
Caf = as.numeric(caf),
Cond = names(list_rts_corr))
return(list(caf))
}
container = c(caf_temp(list_rts_corr[1], list_rts_err[1]),
caf_temp(list_rts_corr[-1], list_rts_err[-1]))
return(container)
}
all_cafs = caf_temp(all_rts_corr, all_rts_err)
all_cafs
# rts_corr and rts_err are a list of rts. Calculates the caf using recursion
caf_temp <- function(list_rts_corr, list_rts_err) {
stopifnot(length(list_rts_corr) == length(list_rts_err))
if (length(list_rts_corr) == 1) {
rts_corr = list_rts_corr[[1]]
rts_err = list_rts_err[[1]]
rts = c(rts_corr, rts_err)
probs = default_caf_probs()
borders <- quantile(rts, probs = probs)
bins <- cut(rts, breaks = borders, labels = FALSE, include.lowest = TRUE)
stopifnot(length(unique(bins)) ==  length(probs)-1)
corr = rep(c(1,0), times = c(length(rts_corr), length(rts_err)))
temp = data.frame(corr = corr,
bins = bins)
caf = tapply(corr, bins, mean)
caf = data.frame(Cond = names(list_rts_corr),
Bin = names(caf),
Caf = as.numeric(caf))
return(list(caf))
}
container = c(caf_temp(list_rts_corr[1], list_rts_err[1]),
caf_temp(list_rts_corr[-1], list_rts_err[-1]))
return(container)
}
all_cafs = caf_temp(all_rts_corr, all_rts_err)
all_cafs
all_cafs = do.call("rbind", caf_temp(all_rts_corr, all_rts_err))
all_cafs
list_rts_corr
list_rts_corr = all_rts_corr[1]
list_rts_err = all_rts_err[1]
list_rts_corr
length(list_rts_corr)
seq(0.1, 0.9, 0.1)
seq(0, 1, length.out = 4+1)
seq(0, 1, length.out = 5+1)
probs = seq(0.1, 0.9, 0.1)
rts_corr = list_rts_corr[[1]]
rts_err = list_rts_err[[1]]
rts_corr
rts_err
quantile(list_rts_corr[[1]], probs = probs)
quants_rts_err = quantile(list_rts_err[[1]], probs = probs)
quants_rts_err
quantile(numeric())
rep(probs, 2)
calc_quantiles_obs <- function(drift_dm_obj, probs = seq(0.1, 0.9, 0.1)) {
if (is.null(drift_dm_obj$obs_data$rts_corr))
return(NULL)
if (is.null(drift_dm_obj$obs_data$rts_err))
return(NULL)
all_rts_corr = drift_dm_obj$obs_data$rts_corr
all_rts_err = drift_dm_obj$obs_data$rts_err
stopifnot(all(names(all_rts_corr) == names(all_rts_err)))
# rts_corr and rts_err are a list of rts.
# Calculates the quantiles using recursion
quantile_temp <- function(list_rts_corr, list_rts_err) {
stopifnot(length(list_rts_corr) == length(list_rts_err))
if (length(list_rts_corr) == 1) {
quants_rts_corr = quantile(list_rts_corr[[1]], probs = probs)
quants_rts_err = quantile(list_rts_err[[1]], probs = probs)
quants = data.frame(Cond = names(list_rts_corr),
Prob = probs,
Quant_Corr = quants_rts_corr,
Quant_Err = quants_rts_corr)
return(list(quants))
}
container = c(quantile_temp(list_rts_corr[1], list_rts_err[1]),
quantile_temp(list_rts_corr[-1], list_rts_err[-1]))
return(container)
}
all_quants = do.call("rbind", quantile_temp(all_rts_corr, all_rts_err))
return(all_quants)
}
# rts_corr and rts_err are a list of rts.
# Calculates the quantiles using recursion
quantile_temp <- function(list_rts_corr, list_rts_err) {
stopifnot(length(list_rts_corr) == length(list_rts_err))
if (length(list_rts_corr) == 1) {
quants_rts_corr = quantile(list_rts_corr[[1]], probs = probs)
quants_rts_err = quantile(list_rts_err[[1]], probs = probs)
quants = data.frame(Cond = names(list_rts_corr),
Prob = probs,
Quant_Corr = quants_rts_corr,
Quant_Err = quants_rts_corr)
return(list(quants))
}
container = c(quantile_temp(list_rts_corr[1], list_rts_err[1]),
quantile_temp(list_rts_corr[-1], list_rts_err[-1]))
return(container)
}
quantile_temp(all_rts_corr)
quantile_temp(all_rts_corr, all_rts_err)
# rts_corr and rts_err are a list of rts.
# Calculates the quantiles using recursion
quantile_temp <- function(list_rts_corr, list_rts_err) {
stopifnot(length(list_rts_corr) == length(list_rts_err))
if (length(list_rts_corr) == 1) {
quants_rts_corr = quantile(list_rts_corr[[1]], probs = probs)
quants_rts_err = quantile(list_rts_err[[1]], probs = probs)
quants_rts_corr = unname(quants_rts_corr)
quants_rts_err = unname(quants_rts_err)
quants = data.frame(Cond = names(list_rts_corr),
Prob = probs,
Quant_Corr = quants_rts_corr,
Quant_Err = quants_rts_corr)
return(list(quants))
}
container = c(quantile_temp(list_rts_corr[1], list_rts_err[1]),
quantile_temp(list_rts_corr[-1], list_rts_err[-1]))
return(container)
}
quantile_temp(all_rts_corr)
quantile_temp(all_rts_corr, all_rts_err)
all_quants = do.call("rbind", quantile_temp(all_rts_corr, all_rts_err))
all_quants
calc_quantiles_obs <- function(drift_dm_obj, probs = seq(0.1, 0.9, 0.1)) {
if (is.null(drift_dm_obj$obs_data$rts_corr))
return(NULL)
if (is.null(drift_dm_obj$obs_data$rts_err))
return(NULL)
all_rts_corr = drift_dm_obj$obs_data$rts_corr
all_rts_err = drift_dm_obj$obs_data$rts_err
stopifnot(all(names(all_rts_corr) == names(all_rts_err)))
# rts_corr and rts_err are a list of rts.
# Calculates the quantiles using recursion
quantile_temp <- function(list_rts_corr, list_rts_err) {
stopifnot(length(list_rts_corr) == length(list_rts_err))
if (length(list_rts_corr) == 1) {
quants_rts_corr = quantile(list_rts_corr[[1]], probs = probs)
quants_rts_err = quantile(list_rts_err[[1]], probs = probs)
quants_rts_corr = unname(quants_rts_corr)
quants_rts_err = unname(quants_rts_err)
quants = data.frame(Cond = names(list_rts_corr),
Prob = probs,
Quant_Corr = quants_rts_corr,
Quant_Err = quants_rts_err)
return(list(quants))
}
container = c(quantile_temp(list_rts_corr[1], list_rts_err[1]),
quantile_temp(list_rts_corr[-1], list_rts_err[-1]))
return(container)
}
all_quants = do.call("rbind", quantile_temp(all_rts_corr, all_rts_err))
return(all_quants)
}
calc_quantiles_obs(one_dm)
calc_cafs_obs <- function(drift_dm_obj, n_bins = 5) {
if (is.null(drift_dm_obj$obs_data$rts_corr))
return(NULL)
if (is.null(drift_dm_obj$obs_data$rts_err))
return(NULL)
all_rts_corr = drift_dm_obj$obs_data$rts_corr
all_rts_err = drift_dm_obj$obs_data$rts_err
stopifnot(all(names(all_rts_corr) == names(all_rts_err)))
# rts_corr and rts_err are a list of rts. Calculates the caf using recursion
caf_temp <- function(list_rts_corr, list_rts_err, n_bins) {
stopifnot(length(list_rts_corr) == length(list_rts_err))
if (length(list_rts_corr) == 1) {
rts_corr = list_rts_corr[[1]]
rts_err = list_rts_err[[1]]
rts = c(rts_corr, rts_err)
probs = seq(0, 1, length.out = n_bins + 1)
borders <- quantile(rts, probs = probs)
bins <- cut(rts, breaks = borders, labels = FALSE, include.lowest = TRUE)
stopifnot(length(unique(bins)) ==  length(probs)-1)
corr = rep(c(1,0), times = c(length(rts_corr), length(rts_err)))
caf = tapply(corr, bins, mean)
caf = data.frame(Cond = names(list_rts_corr),
Bin = names(caf),
P_Corr = as.numeric(caf))
return(list(caf))
}
container = c(caf_temp(list_rts_corr[1], list_rts_err[1], n_bins),
caf_temp(list_rts_corr[-1], list_rts_err[-1], n_bins))
return(container)
}
all_cafs = do.call("rbind", caf_temp(all_rts_corr, all_rts_err, n_bins))
return(all_cafs)
}
calc_cafs_obs(one_dm)
rm(list = ls())
one_dm = dmc_dm(dt = .005)
load_all()
# define upper and lower boundary values
# muc, b, non,   sd,   tau,   A, alpha
lower = c(1, 0.2, 0.1, 0.005, 0.01, 0.01, 2)
upper = c(7, 0.8, 0.6,   0.1, 0.12,  0.4, 8)
rm(list = ls())
one_dm = dmc_dm(dt = .005)
print(one_dm)
# simulate data
data = simulate_data(one_dm, 10000, seed = 1)
# set the data
one_dm = set_data(drift_dm_obj = one_dm, obs_data = data, eval_model = T)
summary(one_dm)
# plot the model
par(mfrow = c(1,1))
#plot_model(one_dm, add_x = FALSE, x_lim = c(0, 0.5))
plot_cafs(one_dm)
# define upper and lower boundary values
# muc, b, non,   sd,   tau,   A, alpha
lower = c(1, 0.2, 0.1, 0.005, 0.01, 0.01, 2)
upper = c(7, 0.8, 0.6,   0.1, 0.12,  0.4, 8)
one_dm = estimate_model(one_dm, lower = lower, upper = upper,
de_control = list(trace = T, parallelType = "auto",
reltol = .1),
polish = F, verbose = F)
?nmkb
one_dm = estimate_model(one_dm, lower = lower, upper = upper,
de_control = list(trace = T, reltol = .1),
polish = F, verbose = F)
one_dm = estimate_model(one_dm, lower = lower, upper = upper,
de_control = list(trace = T, reltol = .1),
polish = F, verbose = T)
one_dm
one_dm = set_model_prms(one_dm, c(muc=6.767, b=0.218, non_dec=0.269, sd_non_dec=0.092, tau=0.083, A=0.356, alpha=4.354))
drift_dm_obj = one_dm
t_max <- drift_dm_obj$prms_solve[["t_max"]]
nT <- drift_dm_obj$prms_solve[["nT"]]
tt <- seq(0, t_max, length.out = nT + 1)
tt
log_like <- 0
red_drift_dm_obj <- drift_dm_obj
red_drift_dm_obj$obs_data <- NULL
pdfs <- get_pdfs(
drift_dm_obj = red_drift_dm_obj,
one_cond = one_cond,
solver = drift_dm_obj$solver
)
one_cond = "comp"
pdfs <- get_pdfs(
drift_dm_obj = red_drift_dm_obj,
one_cond = one_cond,
solver = drift_dm_obj$solver
)
if (min(pdfs$pdf_u) < -1e-3 || min(pdfs$pdf_l) < -1e-3) {
warning(
"unlikely parameter combination encountered; the model produced",
" subst. negative pdf values"
)
return(-Inf)
}
log_like <- log_like + log_like_heart(
drift_dm_obj = drift_dm_obj,
pdf_u = pdfs$pdf_u,
pdf_l = pdfs$pdf_l,
one_cond = one_cond
)
one_cond
plot(pdfs$pdf_u)
plot(pdfs$pdf_l)
drift_dm_obj = drift_dm_obj
pdf_u = pdfs$pdf_u
pdf_l = pdfs$pdf_l
one_cond = one_cond
t_max <- drift_dm_obj$prms_solve[["t_max"]]
nT <- drift_dm_obj$prms_solve[["nT"]]
tt <- seq(0, t_max, length.out = nT + 1)
app_like_u <- stats::approx(
x = tt, y = pdf_u,
xout = drift_dm_obj$obs_data$rts_corr[[one_cond]]
)$y
app_like_u
app_like_l <- stats::approx(
x = tt, y = pdf_l,
xout = drift_dm_obj$obs_data$rts_err[[one_cond]]
)$y
app_like_l
log_like <- sum(log(app_like_u + drift_dm_robust_prm())) +
sum(log(app_like_l + drift_dm_robust_prm()))
app_like_u + drift_dm_robust_prm()
min(app_like_u + drift_dm_robust_prm())
log(app_like_u + drift_dm_robust_prm())
?log
log(app_like_u + drift_dm_robust_prm())
app_like_u = app_like_u + drift_dm_robust_prm()
app_like_l = app_like_u + drift_dm_robust_prm()
min(numeric())
length(app_like_u) > 0
log(.1)
log(-1)
log(numeric())
sum(log(numeric()))
NaN
NaN + 4
app_like_u = app_like_u + drift_dm_robust_prm()
app_like_l = app_like_l + drift_dm_robust_prm()
log_like <- sum(log(app_like_u)) + sum(log(app_like_l))
log_like
app_like_u <- stats::approx(
x = tt, y = pdf_u,
xout = drift_dm_obj$obs_data$rts_corr[[one_cond]]
)$y
app_like_l <- stats::approx(
x = tt, y = pdf_l,
xout = drift_dm_obj$obs_data$rts_err[[one_cond]]
)$y
app_like_u = app_like_u + drift_dm_robust_prm()
app_like_l = app_like_l + drift_dm_robust_prm()
log_like <- sum(log(app_like_u)) + sum(log(app_like_l))
min(app_like_l) < 0
min(app_like_u) < 0
min(app_like_u) < 0 | min(app_like_l) < 0
log(0)
log(Inf)
is.numeric(Inf)
is.double(Inf)
log(NA)
log(Nan)
warning("we encountered an untreated error!", e)
load_all()
one_dm = set_model_prms(one_dm, c(muc=6.767, b=0.218, non_dec=0.269, sd_non_dec=0.092, tau=0.083, A=0.356, alpha=4.354))
one_dm
one_dm$log_like_val
load_all()
one_dm = set_model_prms(one_dm, c(muc=6.767, b=0.218, non_dec=0.269, sd_non_dec=0.092, tau=0.083, A=0.356, alpha=4.354))
one_dm
summary(one_dm)
one_dm = estimate_model(one_dm, lower = lower, upper = upper,
de_control = list(trace = T, reltol = .1),
polish = F, verbose = T,seed = 1)
summary(one_dm)
one_dm
one_dm$optim$bestmem
